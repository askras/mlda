---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.15.2
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

## Первичный анализ данных


### Цель работы

изучение программных средств для организации рабочего места специалиста по машинному обучению и анализу данных.

### Задачи 

 - получение программного доступа к данным, содержащимся в источниках различного типа;
 - выполнение предварительного анализа данных и получение обобщенных характеристик наборов данных;
 - исследование простых методов визуализации данных;
 - изучение основных библиотек Python для работы с данными.

### Продолжительность и сроки сдачи

Продолжительность работы: - 4 часа.

Мягкий дедлайн (5 баллов): 10.10.2023

Жесткий дедлайн (2.5 баллов): 24.10.2023


### Теоретические сведения


Перед выполнением лабораторной работы необходимо ознакомиться с базовыми принципами работы со специализированными библиотеками яхыка Python, используя следующие источники: [1]

Перед выполнением лабораторной работы необходимо ознакомиться с базовыми принципами работы с репозитариями  [2, 3]


### Методика и порядок выполнения работы
Перед выполнением индивидуального задания рекомендуется выполнить все пункты учебной задачи.


### Учебная задача
Необходимо организовать подготовку данных для построения модели (допустим модели классификации). 
В качестве данных выбран набор данных об ирисах Фишера. 
Это, пожалуй, самый известный набор данных, с которого многие начинают исследование алгоритмов машинного обучения.

Данный набор данных предназначен для построения модели классификации. 
Данные о 150 экземплярах ириса (рис. 1), по 50 экземпляров из трёх видов – Ирис щетинистый (Iris Setosa), Ирис виргинский (Iris Virginica) и Ирис разноцветный (Iris Versicolor). 

![Iris Setosa](./img/iris_setosa.jpg "Iris Setosa") | ![Iris Virginica](./img/iris_virginica.jpg "Iris Virginica") | ![Iris Versicolor](./img/iris_versicolor.jpg "Iris Versicolor")
--- | --- | ---
Iris Setosa | Iris Virginica| Iris Versicolor

Для каждого экземпляра измерялись четыре характеристики (в сантиметрах):
1) длина наружной доли околоцветника (sepal length);
2) ширина наружной доли околоцветника (sepal width);
3) длина внутренней доли околоцветника (petal length);
4) ширина внутренней доли околоцветника (petal width).

На основании этого набора данных требуется построить правило классификации, определяющее вид растения по данным измерений. 
Это задача многоклассовой классификации, так как имеется три класса – три вида ириса.


#### Получение данных

Необходимо скачать набор данных из репозитория *Center for Machine Learning and Intelligent Systems* (необходим только один текстовый файл с данными измерений): [http://archive.ics.uci.edu/ml/datasets/Iris](http://archive.ics.uci.edu/ml/datasets/Iris).

Файл `iris.data` при просмотре выглядит следующим образом:

```python
import numpy as np
data_path = "./datasets/iris/iris.data"
data = np.genfromtxt(data_path, delimiter=",")
print(data)
```

Метод genfromtxt() возвращает массив `numpy` (тип `numpy.ndarray`).
Следует обратить внимание, что пятый столбец содержит неопределенные значения `numpy.NaN (объясните – почему?).


<!-- Ваш ответ -->


#### Тип переменной и форма (shape)

Производить вывод всего источника данных – нерациональный путь. 
В реальных задачах данных может оказаться слишком много, поэтому чаще всего используют подвыборку данных для поверхностного обзора исследуемой обучающей выборки:

```python
print ( "Data type : ", type(data) )
print ( "Data shape : ", data.shape )
print ( data[-4:] )
```

#### Получение типа набора данных, строки, элемента

В рамках данной задачи необходимо все-таки получить значения пятого столбца. 
Для этого желательно использовать другой подход

```python
data1 = np.genfromtxt(data_path, delimiter=",", dtype=None)
print('Shape of the dataset:', data1.shape)
print('Dataset type:', type(data1))
print('A single row of the dataset is type of:', type(data1[0]))
print('Types of elements:', type(data1[0][1]), type(data1[0][4]))
print('Dataset:')
print(data1)
```

#### Указание типа столбцов при загрузке данных

Альтернативный вариант загрузки данных в массив `numpy.ndarray`:

```python
dt = np.dtype("f8, f8, f8, f8, U30")
data2 = np.genfromtxt(data_path, delimiter=",", dtype=dt)
print('Shape of the dataset:', data2.shape)
print('Dataset type:', type(data2))
print('A single row of the dataset is type of:', type(data2[0]))
print('Types of elements:', type(data2[0][1]), type(data2[0][4]))
print('Dataset slice:')
print(data2[:10])
```

Поясните различие в структурах данных, получаемых с использованием представленных листингов.


<!-- Ваш ответ -->


#### Построение графиков с использованием Matplotlib

Было загружено 150 элементов данных, но даже при такой маленькой выборке невозможно что-либо сказать о наборе данных. 
Для получения дополнительной информации небходимо визуализировать загруженные данные. 
В нашем случае каждый элемент данных представлен вещественными признаками – это существенно упрощает визуализацию.
Но сложность заключается в том, что приходится работать с элементами 4-мерного пространства, поэтому строится не графическое
представление распределения, а отдельные проекции. 

```python
import matplotlib as mpl
import matplotlib.pyplot as plt
%matplotlib inline

# Data from individual columns
sepal_length = [] # Sepal Length
sepal_width = [] # Sepal Width
petal_length = [] # Petal Length
petal_width = [] # Petal Width

# Traversing the entire data2 collection
for dot in data2:
    sepal_length.append(dot[0])
    sepal_width.append(dot[1])
    petal_length.append(dot[2])
    petal_width.append(dot[3])

# We build graphs based on data projections, taking into account that every 50 types of irises go sequentially
plt.figure(1)

setosa, = plt.plot(sepal_length[:50], sepal_width[:50], 'ro', label='Setosa')
versicolor, = plt.plot(sepal_length[50:100], sepal_width[50:100], 'g^', label='Versicolor')
virginica, = plt.plot(sepal_length[100:150], sepal_width[100:150], 'bs', label='Verginica')
plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)
plt.xlabel('Sepal Length')
plt.ylabel('Sepal Width')

plt.show()
```

На данном графике представлено отображение в плоскости признаков (‘Sepal Width’, ‘Sepal Length’). 
Но исследователь имеет возможность построить столько графиков, сколько необходимо для глубокого анализа данных. 
Изменим код построения графиков для получения распределения в других проекциях:

```python
plt.figure(2)

setosa, = plt.plot(sepal_length[:50], petal_length[:50], 'ro', label='Setosa')
versicolor, = plt.plot(sepal_length[50:100], petal_length[50:100], 'g^', label='Versicolor')
virginica, = plt.plot(sepal_length[100:150], petal_length[100:150], 'bs', label='Verginica')
plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)
plt.xlabel('Sepal Length')
plt.ylabel('Petal Length')

plt.show()
```

```python
plt.figure(3)

setosa, = plt.plot(sepal_length[:50], petal_width[:50], 'ro', label='Setosa')
versicolor, = plt.plot(sepal_length[50:100], petal_width[50:100], 'g^', label='Versicolor')
virginica, = plt.plot(sepal_length[100:150], petal_width[100:150], 'bs', label='Verginica')
plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)
plt.title
plt.xlabel('Sepal Length')
plt.ylabel('Petal Width')

plt.show()
```

Из графического распределения на построенных графиках видно, что вид ирисов Setosa хорошо отделяется, а множества Versicolor и Verginica представляют собой множества, разделение которых является непростой задачей.


Постройте другие проекции исходных данных. 
Сколько всего различных проекций можно построить для данного набора данных?


<!-- Ваш ответ -->

```python
# your code
```

### Важные замечания

Несмотря на кажущуюся простоту и «понятность» данных в результате визуализации, исследователь не должен делать поспешных выводов (например, было бы ошибочно делать вывод по представленным графикам о том, что ирисы Setosa те, у которых petal width менее 0,75).

Следует помнить, что цель первичного исследования данных – получение представления о структуре и природе данных, а не построение модели предсказания, классификации и т.п.


### Индивидуальное задание

1. Подберите набор данных на ресурах [2, 3] и согласуйте свой выбор с преподавателем и другими студентами группы, так
как работа над одинаковыми наборами данных недопустима..

2. Проведите первичный анализ данных. В результате анализа данных студент должен предоставить следующую информацию о наборе данных:
    2.1. Описание набора данных, пояснения, позволяющие лучше понять природу данных.
    Назначение набора данных и возможные модели, которые можно построить на основе данного набора данных
    (практические задачи, решаемые с использованием данного обучающего набора данных).
    Описание каждого признака и его тип.

    2.2. Форма набора данных: количество элементов набора, количество признаков, количество пропущенных значений, среднее значение отдельных
    признаков, максимальные и минимальные значения отдельных признаков и прочие показатели.
    Предположения, которые можно сделать, проведя первичный анализ.
 
    2.3. Графические представления, позволяющие судить о неоднородности исследуемого набора данных.
    Построение графиков желательно произвести по нескольким проекциям.



### Содержание отчета и его форма

Отчет по лабораторной работе должен содержать:

1. Номер и название лабораторной работы; задачи лабораторной работы.

2. Реализация каждого пункта подраздела «Индивидуальное задание» с приведением исходного кода программы, диаграмм и графиков для визуализации данных.

3. Ответы на контрольные вопросы.

4. Листинг программного кода с комментариями, показывающие порядок выполнения лабораторной работы, и результаты, полученные в ходе её выполнения.


### Контрольные вопросы

1. Какие инструментальные средства используются для организации рабочего места специалиста Data Science?

2. Какие библиотеки Python используются для работы в области машинного обучения? Дайте краткую характеристику каждой библиотеке.

3. Почему при реализации систем машинного обучения широкое распространение получили библиотеки Python?


### Список литературы

1. Дж. Плас: Python для сложных задач. Наука о данных и машинное обучение. Питер.,2018, 576 с.

2. [Репозиторий наборов данных для машинного обучения (Центр машинного обучения и интеллектуальных систем)](https://archive.ics.uci.edu/datasets)

3. [Репозиторий наборов данных для машинного обучения (Kaggle)](https://www.kaggle.com/datasets/)
